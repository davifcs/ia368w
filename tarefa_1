import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D
import time
import restthru

host = 'http://127.0.0.1:4950'
# inicia API
restthru.http_init()
# obtem leituras do laser
distances = '/perception/laser/1/distances'
poses = '/motion/pose'

rdistances,_ = restthru.http_get(host+distances)
rposes,_ = restthru.http_get(host+poses)
# # Gira o robo
# delta = 180
# status,code = restthru.http_put(host+'/motion/heading', delta)
# # verifica se o giro foi completado
# progress = 1
# while progress != 0:
# 	time.sleep(1)
# 	progress,code = restthru.http_get(host+'/motion/heading/status')
# # obtem leituras do laser
# rdistances2,code = restthru.http_get(host+laser)
# rdistances += rdistances2


tamCel = 50

numCelX = 200
numCelY = 200

mapa = np.zeros([numCelX,numCelY])

px = rposes["x"]
py = rposes["y"]
pth = rposes["th"]*np.pi/180

#leitura do sensor
mu_array = [np.append(np.asarray(d), i*np.pi/180) for i,d in enumerate(rdistances)]

precisao = 50 
passo = 1*np.pi/180

sigma = np.array([[0.5,0],[0,0.05]])
invSigma = np.linalg.inv(sigma)
Pmin = 0.4

K = 0.02

x = np.linspace(1, numCelX, numCelX)
y = np.linspace(1, numCelY, numCelY)
xx, yy = np.meshgrid(x, y)
max = 0

z = np.zeros([len(x),len(y)])


for i in range(len(x)):
    xi = (i-1)*tamCel+tamCel/2
    for j in range(len(y)):
        yj = (j-1)*tamCel + tamCel/2
        r = np.sqrt((xi-px)**2+(yj-py)**2)
        b = np.arctan2((yj-py),(xi-px))-pth
        for mu in mu_array:
            delta = np.array([r, b]) - mu
            if abs(delta[1])>2*passo:
                if abs(delta[1])>2*passo or abs(delta[0]) > 2*precisao:
                    continue
            if r < mu[0]:
                P = Pmin
            else:
                P = 0.5
            delta[0]  = delta[0]/1000
            z[i][j] = P + (K/(2*np.pi*np.dot(sigma[0][0],sigma[1][1])) + 0.5 - P)*np.exp(-.5 * (np.dot(np.dot(delta,invSigma),delta.T)))
            mapa[i][j] = mapa[i][j] + np.log10(z[i][j]/(1-z[i][j]))
            if z[i][j] > max:
                max = z[i][j]

fig = plt.figure()
ax = fig.gca(projection='3d')
surf = ax.plot_surface(xx,yy,mapa, cmap=cm.coolwarm, linewidth=0, antialiased=False)
fig.colorbar(surf, shrink=0.5, aspect=5)

plt.show()
